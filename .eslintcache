[{"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\index.js":"1","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\reportWebVitals.js":"2","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\PopupWarning.jsx":"3","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\Grid.jsx":"4","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Algorithms\\WeightedSearchAlgorithms.js":"5","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Algorithms\\UnweightedSearchAlgorithms.js":"6","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\GridSquare.jsx":"7","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\Settings.jsx":"8","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\NavBar.jsx":"9","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\AlgoVisualizer.js":"10","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\MainPage\\HomeScreen.jsx":"11","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\DataStructures.js":"12","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\NavBar.jsx":"13","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Toolbar.jsx":"14","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Visualizer.jsx":"15","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Alert.jsx":"16"},{"size":853,"mtime":1642912933998,"results":"17","hashOfConfig":"18"},{"size":375,"mtime":1625410280995,"results":"19","hashOfConfig":"18"},{"size":714,"mtime":1639966896271,"results":"20","hashOfConfig":"18"},{"size":20670,"mtime":1642913377113,"results":"21","hashOfConfig":"18"},{"size":4022,"mtime":1640059729061,"results":"22","hashOfConfig":"18"},{"size":3885,"mtime":1625410280975,"results":"23","hashOfConfig":"18"},{"size":2180,"mtime":1639979324694,"results":"24","hashOfConfig":"18"},{"size":2358,"mtime":1640059806806,"results":"25","hashOfConfig":"18"},{"size":3787,"mtime":1641184383571,"results":"26","hashOfConfig":"18"},{"size":1353,"mtime":1640062563875,"results":"27","hashOfConfig":"18"},{"size":1761,"mtime":1629671936405,"results":"28","hashOfConfig":"18"},{"size":1479,"mtime":1640062579267,"results":"29","hashOfConfig":"18"},{"size":5218,"mtime":1640667543264,"results":"30","hashOfConfig":"18"},{"size":2926,"mtime":1642913468189,"results":"31","hashOfConfig":"18"},{"size":7396,"mtime":1658761446902,"results":"32","hashOfConfig":"18"},{"size":709,"mtime":1637630187156,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"1dn6jl",{"filePath":"37","messages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"36"},{"filePath":"44","messages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"46","messages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"60","messages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"62","messages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"66","messages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\index.js",[],["68","69"],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\reportWebVitals.js",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\PopupWarning.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\Grid.jsx",["70"],"import React from \"react\";\r\nimport $ from \"jquery\";\r\nimport Square from \"./GridSquare\";\r\nimport NavigationBar from \"./NavBar\";\r\n\r\nimport { bfs, dfs, unweightedShortestPath } from \"../Algorithms/UnweightedSearchAlgorithms\";\r\nimport { dijkstra, astar, weightedShortestPath } from \"../Algorithms/WeightedSearchAlgorithms\";\r\nimport Settings from \"./Settings\";\r\n\r\nimport algo from \"../AlgoVisualizer.module.css\";\r\nimport { useState } from \"react\";\r\nimport { useEffect } from \"react\";\r\n\r\nconst GRID_ROWS = 25;\r\nconst GRID_COLS = 72;\r\n\r\nvar unweightedStartNodeX = 5;\r\nvar unweightedStartNodeY = 12;\r\nvar unweightedEndNodeX = 66;\r\nvar unweightedEndNodeY = 12;\r\n\r\nvar weightedStartNodeX = 5;\r\nvar weightedStartNodeY = 12;\r\nvar weightedEndNodeX = 66;\r\nvar weightedEndNodeY = 12;\r\n\r\nexport default class Grid extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            mainGrid: [],\r\n            unweightedGrid: [],\r\n            weightedGrid: [],\r\n            currGrid: \"unweighted\",\r\n            algorithm: null,\r\n            speed: 20,\r\n            isRunning: false,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        // initialize grids\r\n        let uGrid = [],\r\n            wGrid = [];\r\n        for (let i = 0; i < GRID_ROWS; i++) {\r\n            uGrid.push([]);\r\n            wGrid.push([]);\r\n            for (let j = 0; j < GRID_COLS; j++) {\r\n                uGrid[i].push({\r\n                    id: i + \"-\" + j,\r\n                    isWall: false,\r\n                    isStart: i === weightedStartNodeY && j === weightedStartNodeX,\r\n                    isEnd: i === weightedEndNodeY && j === weightedEndNodeX,\r\n                    className:\r\n                        i === weightedStartNodeY && j === weightedStartNodeX\r\n                            ? `${algo.grid_square} ${algo.start}`\r\n                            : i === weightedEndNodeY && j === weightedEndNodeX\r\n                            ? `${algo.grid_square} ${algo.end}`\r\n                            : `${algo.grid_square} ${algo.unselected}`,\r\n                    weight: 0,\r\n                });\r\n                wGrid[i].push({\r\n                    id: i + \"-\" + j,\r\n                    isWall: false,\r\n                    isStart: i === weightedStartNodeY && j === weightedStartNodeX,\r\n                    isEnd: i === weightedEndNodeY && j === weightedEndNodeX,\r\n                    className:\r\n                        i === weightedStartNodeY && j === weightedStartNodeX\r\n                            ? `${algo.grid_square} ${algo.start}`\r\n                            : i === weightedEndNodeY && j === weightedEndNodeX\r\n                            ? `${algo.grid_square} ${algo.end}`\r\n                            : `${algo.grid_square} ${algo.unselected}`,\r\n                    weight: 0,\r\n                });\r\n            }\r\n        }\r\n\r\n        this.setState({ unweightedGrid: uGrid });\r\n        this.setState({ weightedGrid: wGrid });\r\n\r\n        // set main grid to unweighted grid\r\n        this.setState({ mainGrid: uGrid });\r\n    }\r\n\r\n    handleClick(x, y) {\r\n        if ($(\"#\" + y + \"-\" + x).has(\"img\").length === 1) {\r\n            return;\r\n        }\r\n\r\n        let newGrid = this.state.mainGrid.slice();\r\n\r\n        if (this.state.currGrid === \"unweighted\") {\r\n            newGrid[y][x] = {\r\n                ...newGrid[y][x],\r\n                isWall: !newGrid[y][x].isWall,\r\n                className: newGrid[y][x].isWall ? `${algo.grid_square} ${algo.unselected}` : `${algo.grid_square} ${algo.selected}`,\r\n            };\r\n        } else {\r\n            newGrid[y][x] = {\r\n                ...newGrid[y][x],\r\n                weight: newGrid[y][x].weight + 1 === 5 ? 0 : newGrid[y][x].weight + 1,\r\n            };\r\n        }\r\n        this.setState({ mainGrid: newGrid });\r\n    }\r\n\r\n    ///////////////////////////// algorithm animations /////////////////////////////\r\n\r\n    /********************* Unweighted algorithms *********************/\r\n    animateBFS(grid) {\r\n        $(`.${algo.algo_app}`).css(\"pointer-events\", \"none\");\r\n        const path = bfs(grid, unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY);\r\n        let speed = this.state.speed;\r\n        let stateGrid = this.state.mainGrid;\r\n\r\n        for (let i = 1; i < path.length - 1; i++) {\r\n            setTimeout(() => {\r\n                let id = path[i][1] + \"-\" + path[i][0];\r\n                $(\"#\" + id).addClass(`${algo.visited}`);\r\n                stateGrid[path[i][1]][path[i][0]].className = `${algo.grid_square} ${algo.visited}`;\r\n            }, speed * i);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            $(`.${algo.algo_app}`).css(\"pointer-events\", \"auto\");\r\n            this.drawUnweightedShortestPath(unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY, speed, path);\r\n            this.setState({ mainGrid: stateGrid });\r\n        }, path.length * speed);\r\n    }\r\n\r\n    animateDFS(grid) {\r\n        $(`.${algo.algo_app}`).css(\"pointer-events\", \"none\");\r\n        const path = dfs(grid, unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY);\r\n        let speed = this.state.speed;\r\n        let stateGrid = this.state.mainGrid;\r\n\r\n        for (let i = 1; i < path.length - 1; i++) {\r\n            setTimeout(() => {\r\n                let id = path[i][1] + \"-\" + path[i][0];\r\n                $(\"#\" + id).addClass(`${algo.visited}`);\r\n                stateGrid[path[i][1]][path[i][0]].className = `${algo.grid_square} ${algo.visited}`;\r\n            }, speed * i);\r\n        }\r\n        setTimeout(() => {\r\n            $(`.${algo.algo_app}`).css(\"pointer-events\", \"auto\");\r\n            this.drawUnweightedShortestPath(unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY, speed, path);\r\n            this.setState({ mainGrid: stateGrid });\r\n        }, path.length * speed);\r\n    }\r\n\r\n    /********************* Weighted algorithms *********************/\r\n\r\n    animateDijkstra(grid) {\r\n        $(`.${algo.algo_app}`).css(\"pointer-events\", \"none\");\r\n        const path = dijkstra(grid, weightedStartNodeX, weightedStartNodeY, weightedEndNodeX, weightedEndNodeY);\r\n        let speed = this.state.speed;\r\n        let stateGrid = this.state.mainGrid;\r\n\r\n        for (let i = 1; i < path.length - 1; i++) {\r\n            setTimeout(() => {\r\n                let id = path[i][1] + \"-\" + path[i][0];\r\n                $(\"#\" + id).addClass(`${algo.visited}`);\r\n                stateGrid[path[i][1]][path[i][0]].className = `${algo.grid_square} ${algo.visited}`;\r\n            }, speed * i);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            $(`.${algo.algo_app}`).css(\"pointer-events\", \"auto\");\r\n            this.drawWeightedShortestPath(weightedEndNodeX, weightedEndNodeY, speed, path);\r\n            this.setState({ mainGrid: stateGrid });\r\n        }, path.length * speed);\r\n    }\r\n\r\n    animateAstar(grid) {\r\n        $(`.${algo.algo_app}`).css(\"pointer-events\", \"none\");\r\n        const path = astar(grid, weightedStartNodeX, weightedStartNodeY, weightedEndNodeX, weightedEndNodeY);\r\n\r\n        let speed = this.state.speed;\r\n        let stateGrid = this.state.mainGrid;\r\n\r\n        for (let i = 1; i < path.length - 1; i++) {\r\n            setTimeout(() => {\r\n                let id = path[i][1] + \"-\" + path[i][0];\r\n                $(\"#\" + id).addClass(`${algo.visited}`);\r\n                stateGrid[path[i][1]][path[i][0]].className = `${algo.grid_square} ${algo.visited}`;\r\n            }, speed * i);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            $(`${algo.grid}`).css(\"pointer-events\", \"auto\");\r\n            this.drawWeightedShortestPath(weightedEndNodeX, weightedEndNodeY, speed, path);\r\n            this.setState({ mainGrid: stateGrid });\r\n        }, speed * path.length);\r\n    }\r\n\r\n    /////////////////// draw paths //////////////////////////\r\n\r\n    drawUnweightedShortestPath(unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY, speed, path) {\r\n        this.setState({ isRunning: false });\r\n        let grid = this.state.mainGrid;\r\n        const shortestPath = unweightedShortestPath(unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY, path);\r\n        for (let i = 1; i < shortestPath.length; i++) {\r\n            setTimeout(() => {\r\n                let id = shortestPath[i][1] + \"-\" + shortestPath[i][0];\r\n                $(\"#\" + id).attr(\"class\", `${algo.grid_square} ${algo.shortestpath}`);\r\n                grid[shortestPath[i][1]][shortestPath[i][0]].className = `${algo.grid_square} ${algo.shortestpath}`;\r\n            }, speed * i * 2);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            $(`.${algo.algo_app}`).css(\"pointer-events\", \"auto\");\r\n            this.setState({ mainGrid: grid });\r\n        }, speed * shortestPath.length * 2);\r\n    }\r\n\r\n    drawWeightedShortestPath(weightedStartNodeX, weightedStartNodeY, speed, path) {\r\n        this.setState({ isRunning: false });\r\n        let grid = this.state.mainGrid;\r\n        const shortestPath = weightedShortestPath(weightedStartNodeX, weightedStartNodeY, path);\r\n        for (let i = 0; i < shortestPath.length - 1; i++) {\r\n            setTimeout(() => {\r\n                let id = shortestPath[i][1] + \"-\" + shortestPath[i][0];\r\n                $(\"#\" + id).attr(\"class\", `${algo.grid_square} ${algo.shortestpath}`);\r\n                grid[shortestPath[i][1]][shortestPath[i][0]].className = `${algo.grid_square} ${algo.shortestpath}`;\r\n            }, speed * i * 2);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            $(`.${algo.algo_app}`).css(\"pointer-events\", \"auto\");\r\n            this.setState({ mainGrid: grid });\r\n        }, shortestPath.length * speed * 2);\r\n    }\r\n\r\n    /////////////////// visualize button function //////////////////////////\r\n    visualizeAlgorithm() {\r\n        this.resetGrid();\r\n        const { algorithm, mainGrid } = this.state;\r\n        switch (algorithm) {\r\n            case \"BFS\":\r\n                this.animateBFS(mainGrid);\r\n                this.setState({ isRunning: true });\r\n                break;\r\n            case \"DFS\":\r\n                this.animateDFS(mainGrid);\r\n                this.setState({ isRunning: true });\r\n                break;\r\n            case \"Dijkstra's\":\r\n                this.animateDijkstra(mainGrid);\r\n                this.setState({ isRunning: true });\r\n                break;\r\n            case \"A*\":\r\n                this.animateAstar(mainGrid);\r\n                this.setState({ isRunning: true });\r\n                break;\r\n            default:\r\n                $(`#${algo.popup}`).fadeIn(150);\r\n                break;\r\n        }\r\n    }\r\n\r\n    changeAlgorithm(key) {\r\n        this.setState({ algorithm: key });\r\n    }\r\n\r\n    changeSpeed(speed) {\r\n        if (speed === \"slow\") {\r\n            this.setState({ speed: 30 });\r\n        } else if (speed === \"med\") {\r\n            this.setState({ speed: 20 });\r\n        } else {\r\n            this.setState({ speed: 15 });\r\n        }\r\n    }\r\n\r\n    changeGrid(type) {\r\n        this.resetGrid();\r\n        if (type === \"weighted\" && this.state.currGrid === \"unweighted\") {\r\n            this.setState({\r\n                currGrid: \"weighted\",\r\n                unweightedGrid: this.state.mainGrid,\r\n                mainGrid: this.state.weightedGrid,\r\n            });\r\n        } else if (type === \"unweighted\" && this.state.currGrid === \"weighted\") {\r\n            this.setState({\r\n                currGrid: \"unweighted\",\r\n                weightedGrid: this.state.mainGrid,\r\n                mainGrid: this.state.unweightedGrid,\r\n            });\r\n        }\r\n    }\r\n\r\n    generateRandomGrid() {\r\n        let grid = this.state.mainGrid.slice();\r\n        if (this.state.currGrid === \"unweighted\") {\r\n            for (let i = 0; i < GRID_ROWS; i++) {\r\n                for (let j = 0; j < GRID_COLS; j++) {\r\n                    if ((i === unweightedStartNodeY && j === unweightedStartNodeX) || (i === unweightedEndNodeY && j === unweightedEndNodeX)) {\r\n                        continue;\r\n                    }\r\n                    grid[i][j].isWall = Math.random() * 5 > 4;\r\n                    grid[i][j].className = grid[i][j].isWall ? `${algo.grid_square} ${algo.selected}` : `${algo.grid_square} ${algo.unselected}`;\r\n                }\r\n            }\r\n            this.setState({ mainGrid: grid });\r\n        } else {\r\n            for (let i = 0; i < GRID_ROWS; i++) {\r\n                for (let j = 0; j < GRID_COLS; j++) {\r\n                    if ((i === weightedStartNodeY && j === weightedStartNodeX) || (i === weightedEndNodeY && j === weightedEndNodeX)) {\r\n                        grid[i][j].weight = 0;\r\n                        continue;\r\n                    } else {\r\n                        if (Math.random() > 0.5) {\r\n                            grid[i][j].weight = Math.trunc(Math.random() * 4 + 1);\r\n                        } else {\r\n                            grid[i][j].weight = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ mainGrid: grid });\r\n        }\r\n    }\r\n\r\n    clearWeightsAndWalls() {\r\n        let grid = [];\r\n        if (this.state.currGrid === \"unweighted\") {\r\n            for (let i = 0; i < GRID_ROWS; i++) {\r\n                grid.push([]);\r\n                for (let j = 0; j < GRID_COLS; j++) {\r\n                    grid[i].push({\r\n                        id: i + \"-\" + j,\r\n                        isStart: i === unweightedStartNodeY && j === unweightedStartNodeX,\r\n                        isEnd: i === unweightedEndNodeY && j === unweightedEndNodeX,\r\n                        className:\r\n                            i === unweightedStartNodeY && j === unweightedStartNodeX\r\n                                ? `${algo.grid_square} ${algo.start}`\r\n                                : i === unweightedEndNodeY && j === unweightedEndNodeX\r\n                                ? `${algo.grid_square} ${algo.end}`\r\n                                : `${algo.grid_square} ${algo.unselected}`,\r\n                        weight: 0,\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 0; i < GRID_ROWS; i++) {\r\n                grid.push([]);\r\n                for (let j = 0; j < GRID_COLS; j++) {\r\n                    grid[i].push({\r\n                        id: i + \"-\" + j,\r\n                        isStart: i === weightedStartNodeY && j === weightedStartNodeX,\r\n                        isEnd: i === weightedEndNodeY && j === weightedEndNodeX,\r\n                        className:\r\n                            i === weightedStartNodeY && j === weightedStartNodeX\r\n                                ? `${algo.grid_square} ${algo.start}`\r\n                                : i === weightedEndNodeY && j === weightedEndNodeX\r\n                                ? `${algo.grid_square} ${algo.end}`\r\n                                : `${algo.grid_square} ${algo.unselected}`,\r\n                        weight: 0,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        this.setState({ mainGrid: grid });\r\n    }\r\n\r\n    dragAndDropUpdate(id, e) {\r\n        let newGrid = this.state.mainGrid.slice();\r\n        let data = JSON.parse(e.dataTransfer.getData(\"data\"));\r\n\r\n        // sX = startX, sY = startY\r\n        // eX = endX, eY = endY\r\n\r\n        let sY = data[1].substring(0, data[1].indexOf(\"-\"));\r\n        let sX = data[1].substring(data[1].indexOf(\"-\") + 1, data[1].length);\r\n        let eY = id.substring(0, id.indexOf(\"-\"));\r\n        let eX = id.substring(id.indexOf(\"-\") + 1, id.length);\r\n\r\n        if (data[0] === `${algo.start}`) {\r\n            newGrid[sY][sX].isStart = false;\r\n            newGrid[eY][eX].isStart = true;\r\n\r\n            newGrid[sY][sX].className = `${algo.grid_square} ${algo.unselected}`;\r\n            newGrid[eY][eX].className = `${algo.grid_square} ${algo.start}`;\r\n        } else {\r\n            newGrid[sY][sX].isEnd = false;\r\n            newGrid[eY][eX].isEnd = true;\r\n\r\n            newGrid[sY][sX].className = `${algo.grid_square} ${algo.unselected}`;\r\n            newGrid[eY][eX].className = `${algo.grid_square} ${algo.end}`;\r\n        }\r\n\r\n        if (newGrid[eY][eX].isWall) {\r\n            newGrid[eY][eX].isWall = false;\r\n        }\r\n\r\n        if (this.state.currGrid === \"weighted\") {\r\n            newGrid[eY][eX].weight = 0;\r\n        }\r\n\r\n        this.setState({ mainGrid: newGrid });\r\n    }\r\n\r\n    resetGrid() {\r\n        // set visited nodes to blank nodes but not blocked off nodes\r\n        let grid = this.state.mainGrid;\r\n        for (let i = 0; i < GRID_ROWS; i++) {\r\n            for (let j = 0; j < GRID_COLS; j++) {\r\n                // set visited nodes to blank nodes\r\n                let nodeClass = String(grid[i][j].className);\r\n                if (nodeClass.includes(\"visited\") || nodeClass.includes(\"shortestpath\")) {\r\n                    grid[i][j].className = `${algo.grid_square} ${algo.unselected}`;\r\n                }\r\n            }\r\n        }\r\n        this.setState({ mainGrid: grid });\r\n    }\r\n\r\n    /////////////////// Render ///////////////////\r\n    render() {\r\n        const { mainGrid } = this.state;\r\n        return (\r\n            <div className={`${algo.algo_app}`} align=\"center\">\r\n                <Settings changeSpeed={(speed) => this.changeSpeed(speed)} />\r\n                <NavigationBar\r\n                    onClick={() => this.visualizeAlgorithm()}\r\n                    changeAlgorithm={(key) => this.changeAlgorithm(key)}\r\n                    changeGrid={(type) => this.changeGrid(type)}\r\n                    algorithm={this.state.algorithm}\r\n                    generateNewGrid={() => this.generateRandomGrid()}\r\n                    clearWeightsAndWalls={() => this.clearWeightsAndWalls()}\r\n                />\r\n                <div id={`${algo.grid}`}>\r\n                    {mainGrid.map((row, key) => {\r\n                        return (\r\n                            <div className={`${algo.grid_row}`} key={key}>\r\n                                {row.map((node, key) => {\r\n                                    return (\r\n                                        <Square\r\n                                            {...node}\r\n                                            handleClick={(j, i) => this.handleClick(j, i)}\r\n                                            drag={drag()}\r\n                                            drop={drop(node.id, this.state.currGrid)}\r\n                                            key={key}\r\n                                            dragAndDropUpdate={(e, id) => this.dragAndDropUpdate(e, id)}\r\n                                        />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n                <Timer isRunning={this.state.isRunning} />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst Timer = (props) => {\r\n    const [time, setTime] = useState(0);\r\n\r\n    document.addEventListener(\"click\", (e) => {\r\n        if (e.target.id === \"visualize-btn\") {\r\n            setTime(0);\r\n        }\r\n    });\r\n    useEffect(() => {\r\n        if (props.isRunning == false) {\r\n            return;\r\n        }\r\n        const interval = setInterval(() => {\r\n            setTime(time + 0.1);\r\n        }, 100);\r\n\r\n        return () => clearInterval(interval);\r\n    });\r\n\r\n    return <div style={{ marginTop: \"1em\", fontSize: \"1.5em\" }}>Time elapsed: {time.toFixed(1)} seconds</div>;\r\n};\r\n\r\n// JavaScript functions\r\n\r\n// drag and drop functions\r\nconst drag = () => (e) => {\r\n    let data = [e.target.id, e.target.parentNode.id];\r\n    e.dataTransfer.setData(\"data\", JSON.stringify(data));\r\n};\r\n\r\nconst drop = (id, grid) => (e) => {\r\n    e.preventDefault();\r\n    let data = JSON.parse(e.dataTransfer.getData(\"data\"));\r\n\r\n    // stringEndId represents the node where data is being dropped\r\n\r\n    let stringEndId = String(id);\r\n    let y = parseInt(stringEndId.substring(0, stringEndId.indexOf(\"-\")));\r\n    let x = parseInt(stringEndId.substring(stringEndId.indexOf(\"-\") + 1, stringEndId.length));\r\n    e.target.appendChild(document.getElementById(data[0]));\r\n\r\n    if (grid === \"unweighted\") {\r\n        if (data[0] === `${algo.start}`) {\r\n            unweightedStartNodeX = x;\r\n            unweightedStartNodeY = y;\r\n        } else {\r\n            unweightedEndNodeX = x;\r\n            unweightedEndNodeY = y;\r\n        }\r\n    } else {\r\n        if (data[0] === `${algo.start}`) {\r\n            weightedStartNodeX = x;\r\n            weightedStartNodeY = y;\r\n        } else {\r\n            weightedEndNodeX = x;\r\n            weightedEndNodeY = y;\r\n        }\r\n    }\r\n};\r\n","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Algorithms\\WeightedSearchAlgorithms.js",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Algorithms\\UnweightedSearchAlgorithms.js",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\GridSquare.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\Settings.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\NavBar.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\AlgoVisualizer.js",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\MainPage\\HomeScreen.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\DataStructures.js",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\NavBar.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Toolbar.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Visualizer.jsx",["71"],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Alert.jsx",[],{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","replacedBy":"75"},{"ruleId":"76","severity":1,"message":"77","line":467,"column":29,"nodeType":"78","messageId":"79","endLine":467,"endColumn":31},{"ruleId":"76","severity":1,"message":"77","line":229,"column":53,"nodeType":"78","messageId":"79","endLine":229,"endColumn":55},"no-native-reassign",["80"],"no-negated-in-lhs",["81"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation"]