[{"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\index.js":"1","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\reportWebVitals.js":"2","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\PopupWarning.jsx":"3","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\Grid.jsx":"4","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Algorithms\\WeightedSearchAlgorithms.js":"5","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Algorithms\\UnweightedSearchAlgorithms.js":"6","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\GridSquare.jsx":"7","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\Settings.jsx":"8","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\NavBar.jsx":"9","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\AlgoVisualizer.js":"10","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\MainPage\\HomeScreen.jsx":"11","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\DataStructures.js":"12","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\NavBar.jsx":"13","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Toolbar.jsx":"14","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Visualizer.jsx":"15","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Alert.jsx":"16","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\Legend.jsx":"17"},{"size":852,"mtime":1629671310414,"results":"18","hashOfConfig":"19"},{"size":375,"mtime":1625410280995,"results":"20","hashOfConfig":"19"},{"size":714,"mtime":1639966896271,"results":"21","hashOfConfig":"19"},{"size":20758,"mtime":1640666764080,"results":"22","hashOfConfig":"19"},{"size":4022,"mtime":1640059729061,"results":"23","hashOfConfig":"19"},{"size":3885,"mtime":1625410280975,"results":"24","hashOfConfig":"19"},{"size":2180,"mtime":1639979324694,"results":"25","hashOfConfig":"19"},{"size":2358,"mtime":1640059806806,"results":"26","hashOfConfig":"19"},{"size":3787,"mtime":1640667549508,"results":"27","hashOfConfig":"19"},{"size":1353,"mtime":1640062563875,"results":"28","hashOfConfig":"19"},{"size":1761,"mtime":1629671936405,"results":"29","hashOfConfig":"19"},{"size":1479,"mtime":1640062579267,"results":"30","hashOfConfig":"19"},{"size":5218,"mtime":1640667543264,"results":"31","hashOfConfig":"19"},{"size":2587,"mtime":1629815215961,"results":"32","hashOfConfig":"19"},{"size":7245,"mtime":1640270957624,"results":"33","hashOfConfig":"19"},{"size":709,"mtime":1637630187156,"results":"34","hashOfConfig":"19"},{"size":883,"mtime":1640667332512,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"hqij3n",{"filePath":"39","messages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"38"},{"filePath":"46","messages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"56","messages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"58","messages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"60","messages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"62","messages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"66","messages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"38"},{"filePath":"69","messages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"71","messages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\index.js",[],["73","74"],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\reportWebVitals.js",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\PopupWarning.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\Grid.jsx",["75"],"import React from \"react\";\r\nimport $ from \"jquery\";\r\nimport Square from \"./GridSquare\";\r\nimport NavigationBar from \"./NavBar\";\r\n\r\nimport { bfs, dfs, unweightedShortestPath } from \"../Algorithms/UnweightedSearchAlgorithms\";\r\nimport { dijkstra, astar, weightedShortestPath } from \"../Algorithms/WeightedSearchAlgorithms\";\r\nimport Settings from \"./Settings\";\r\nimport Legend from \"./Legend\";\r\n\r\nimport algo from \"../AlgoVisualizer.module.css\";\r\nimport { useState } from \"react\";\r\nimport { useEffect } from \"react\";\r\n\r\nconst GRID_ROWS = 25;\r\nconst GRID_COLS = 72;\r\n\r\nvar unweightedStartNodeX = 5;\r\nvar unweightedStartNodeY = 12;\r\nvar unweightedEndNodeX = 66;\r\nvar unweightedEndNodeY = 12;\r\n\r\nvar weightedStartNodeX = 5;\r\nvar weightedStartNodeY = 12;\r\nvar weightedEndNodeX = 66;\r\nvar weightedEndNodeY = 12;\r\n\r\nexport default class Grid extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            mainGrid: [],\r\n            unweightedGrid: [],\r\n            weightedGrid: [],\r\n            currGrid: \"unweighted\",\r\n            algorithm: null,\r\n            speed: 20,\r\n            isRunning: false,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        // initialize grids\r\n        let uGrid = [],\r\n            wGrid = [];\r\n        for (let i = 0; i < GRID_ROWS; i++) {\r\n            uGrid.push([]);\r\n            wGrid.push([]);\r\n            for (let j = 0; j < GRID_COLS; j++) {\r\n                uGrid[i].push({\r\n                    id: i + \"-\" + j,\r\n                    isWall: false,\r\n                    isStart: i === weightedStartNodeY && j === weightedStartNodeX,\r\n                    isEnd: i === weightedEndNodeY && j === weightedEndNodeX,\r\n                    className:\r\n                        i === weightedStartNodeY && j === weightedStartNodeX\r\n                            ? `${algo.grid_square} ${algo.start}`\r\n                            : i === weightedEndNodeY && j === weightedEndNodeX\r\n                            ? `${algo.grid_square} ${algo.end}`\r\n                            : `${algo.grid_square} ${algo.unselected}`,\r\n                    weight: 0,\r\n                });\r\n                wGrid[i].push({\r\n                    id: i + \"-\" + j,\r\n                    isWall: false,\r\n                    isStart: i === weightedStartNodeY && j === weightedStartNodeX,\r\n                    isEnd: i === weightedEndNodeY && j === weightedEndNodeX,\r\n                    className:\r\n                        i === weightedStartNodeY && j === weightedStartNodeX\r\n                            ? `${algo.grid_square} ${algo.start}`\r\n                            : i === weightedEndNodeY && j === weightedEndNodeX\r\n                            ? `${algo.grid_square} ${algo.end}`\r\n                            : `${algo.grid_square} ${algo.unselected}`,\r\n                    weight: 0,\r\n                });\r\n            }\r\n        }\r\n\r\n        this.setState({ unweightedGrid: uGrid });\r\n        this.setState({ weightedGrid: wGrid });\r\n\r\n        // set main grid to unweighted grid\r\n        this.setState({ mainGrid: uGrid });\r\n    }\r\n\r\n    handleClick(x, y) {\r\n        if ($(\"#\" + y + \"-\" + x).has(\"img\").length === 1) {\r\n            return;\r\n        }\r\n\r\n        let newGrid = this.state.mainGrid.slice();\r\n\r\n        if (this.state.currGrid === \"unweighted\") {\r\n            newGrid[y][x] = {\r\n                ...newGrid[y][x],\r\n                isWall: !newGrid[y][x].isWall,\r\n                className: newGrid[y][x].isWall ? `${algo.grid_square} ${algo.unselected}` : `${algo.grid_square} ${algo.selected}`,\r\n            };\r\n        } else {\r\n            newGrid[y][x] = {\r\n                ...newGrid[y][x],\r\n                weight: newGrid[y][x].weight + 1 === 5 ? 0 : newGrid[y][x].weight + 1,\r\n            };\r\n        }\r\n        this.setState({ mainGrid: newGrid });\r\n    }\r\n\r\n    ///////////////////////////// algorithm animations /////////////////////////////\r\n\r\n    /********************* Unweighted algorithms *********************/\r\n    animateBFS(grid) {\r\n        $(`.${algo.algo_app}`).css(\"pointer-events\", \"none\");\r\n        const path = bfs(grid, unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY);\r\n        let speed = this.state.speed;\r\n        let stateGrid = this.state.mainGrid;\r\n\r\n        for (let i = 1; i < path.length - 1; i++) {\r\n            setTimeout(() => {\r\n                let id = path[i][1] + \"-\" + path[i][0];\r\n                $(\"#\" + id).addClass(`${algo.visited}`);\r\n                stateGrid[path[i][1]][path[i][0]].className = `${algo.grid_square} ${algo.visited}`;\r\n            }, speed * i);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            $(`.${algo.algo_app}`).css(\"pointer-events\", \"auto\");\r\n            this.drawUnweightedShortestPath(unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY, speed, path);\r\n            this.setState({ mainGrid: stateGrid });\r\n        }, path.length * speed);\r\n    }\r\n\r\n    animateDFS(grid) {\r\n        $(`.${algo.algo_app}`).css(\"pointer-events\", \"none\");\r\n        const path = dfs(grid, unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY);\r\n        let speed = this.state.speed;\r\n        let stateGrid = this.state.mainGrid;\r\n\r\n        for (let i = 1; i < path.length - 1; i++) {\r\n            setTimeout(() => {\r\n                let id = path[i][1] + \"-\" + path[i][0];\r\n                $(\"#\" + id).addClass(`${algo.visited}`);\r\n                stateGrid[path[i][1]][path[i][0]].className = `${algo.grid_square} ${algo.visited}`;\r\n            }, speed * i);\r\n        }\r\n        setTimeout(() => {\r\n            $(`.${algo.algo_app}`).css(\"pointer-events\", \"auto\");\r\n            this.drawUnweightedShortestPath(unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY, speed, path);\r\n            this.setState({ mainGrid: stateGrid });\r\n        }, path.length * speed);\r\n    }\r\n\r\n    /********************* Weighted algorithms *********************/\r\n\r\n    animateDijkstra(grid) {\r\n        $(`.${algo.algo_app}`).css(\"pointer-events\", \"none\");\r\n        const path = dijkstra(grid, weightedStartNodeX, weightedStartNodeY, weightedEndNodeX, weightedEndNodeY);\r\n        let speed = this.state.speed;\r\n        let stateGrid = this.state.mainGrid;\r\n\r\n        for (let i = 1; i < path.length - 1; i++) {\r\n            setTimeout(() => {\r\n                let id = path[i][1] + \"-\" + path[i][0];\r\n                $(\"#\" + id).addClass(`${algo.visited}`);\r\n                stateGrid[path[i][1]][path[i][0]].className = `${algo.grid_square} ${algo.visited}`;\r\n            }, speed * i);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            $(`.${algo.algo_app}`).css(\"pointer-events\", \"auto\");\r\n            this.drawWeightedShortestPath(weightedEndNodeX, weightedEndNodeY, speed, path);\r\n            this.setState({ mainGrid: stateGrid });\r\n        }, path.length * speed);\r\n    }\r\n\r\n    animateAstar(grid) {\r\n        $(`.${algo.algo_app}`).css(\"pointer-events\", \"none\");\r\n        const path = astar(grid, weightedStartNodeX, weightedStartNodeY, weightedEndNodeX, weightedEndNodeY);\r\n\r\n        let speed = this.state.speed;\r\n        let stateGrid = this.state.mainGrid;\r\n\r\n        for (let i = 1; i < path.length - 1; i++) {\r\n            setTimeout(() => {\r\n                let id = path[i][1] + \"-\" + path[i][0];\r\n                $(\"#\" + id).addClass(`${algo.visited}`);\r\n                stateGrid[path[i][1]][path[i][0]].className = `${algo.grid_square} ${algo.visited}`;\r\n            }, speed * i);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            $(`${algo.grid}`).css(\"pointer-events\", \"auto\");\r\n            this.drawWeightedShortestPath(weightedEndNodeX, weightedEndNodeY, speed, path);\r\n            this.setState({ mainGrid: stateGrid });\r\n        }, speed * path.length);\r\n    }\r\n\r\n    /////////////////// draw paths //////////////////////////\r\n\r\n    drawUnweightedShortestPath(unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY, speed, path) {\r\n        this.setState({ isRunning: false });\r\n        let grid = this.state.mainGrid;\r\n        const shortestPath = unweightedShortestPath(unweightedStartNodeX, unweightedStartNodeY, unweightedEndNodeX, unweightedEndNodeY, path);\r\n        for (let i = 1; i < shortestPath.length; i++) {\r\n            setTimeout(() => {\r\n                let id = shortestPath[i][1] + \"-\" + shortestPath[i][0];\r\n                $(\"#\" + id).attr(\"class\", `${algo.grid_square} ${algo.shortestpath}`);\r\n                grid[shortestPath[i][1]][shortestPath[i][0]].className = `${algo.grid_square} ${algo.shortestpath}`;\r\n            }, speed * i * 2);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            $(`.${algo.algo_app}`).css(\"pointer-events\", \"auto\");\r\n            this.setState({ mainGrid: grid });\r\n        }, speed * shortestPath.length * 2);\r\n    }\r\n\r\n    drawWeightedShortestPath(weightedStartNodeX, weightedStartNodeY, speed, path) {\r\n        this.setState({ isRunning: false });\r\n        let grid = this.state.mainGrid;\r\n        const shortestPath = weightedShortestPath(weightedStartNodeX, weightedStartNodeY, path);\r\n        for (let i = 0; i < shortestPath.length - 1; i++) {\r\n            setTimeout(() => {\r\n                let id = shortestPath[i][1] + \"-\" + shortestPath[i][0];\r\n                $(\"#\" + id).attr(\"class\", `${algo.grid_square} ${algo.shortestpath}`);\r\n                grid[shortestPath[i][1]][shortestPath[i][0]].className = `${algo.grid_square} ${algo.shortestpath}`;\r\n            }, speed * i * 2);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            $(`.${algo.algo_app}`).css(\"pointer-events\", \"auto\");\r\n            this.setState({ mainGrid: grid });\r\n        }, shortestPath.length * speed * 2);\r\n    }\r\n\r\n    /////////////////// visualize button function //////////////////////////\r\n    visualizeAlgorithm() {\r\n        this.resetGrid();\r\n        const { algorithm, mainGrid } = this.state;\r\n        switch (algorithm) {\r\n            case \"BFS\":\r\n                this.animateBFS(mainGrid);\r\n                this.setState({ isRunning: true });\r\n                break;\r\n            case \"DFS\":\r\n                this.animateDFS(mainGrid);\r\n                this.setState({ isRunning: true });\r\n                break;\r\n            case \"Dijkstra's\":\r\n                this.animateDijkstra(mainGrid);\r\n                this.setState({ isRunning: true });\r\n                break;\r\n            case \"A*\":\r\n                this.animateAstar(mainGrid);\r\n                this.setState({ isRunning: true });\r\n                break;\r\n            default:\r\n                $(`#${algo.popup}`).fadeIn(150);\r\n                break;\r\n        }\r\n    }\r\n\r\n    changeAlgorithm(key) {\r\n        this.setState({ algorithm: key });\r\n    }\r\n\r\n    changeSpeed(speed) {\r\n        if (speed === \"slow\") {\r\n            this.setState({ speed: 30 });\r\n        } else if (speed === \"med\") {\r\n            this.setState({ speed: 20 });\r\n        } else {\r\n            this.setState({ speed: 15 });\r\n        }\r\n    }\r\n\r\n    changeGrid(type) {\r\n        this.resetGrid();\r\n        if (type === \"weighted\" && this.state.currGrid === \"unweighted\") {\r\n            this.setState({\r\n                currGrid: \"weighted\",\r\n                unweightedGrid: this.state.mainGrid,\r\n                mainGrid: this.state.weightedGrid,\r\n            });\r\n        } else if (type === \"unweighted\" && this.state.currGrid === \"weighted\") {\r\n            this.setState({\r\n                currGrid: \"unweighted\",\r\n                weightedGrid: this.state.mainGrid,\r\n                mainGrid: this.state.unweightedGrid,\r\n            });\r\n        }\r\n    }\r\n\r\n    generateRandomGrid() {\r\n        let grid = this.state.mainGrid.slice();\r\n        if (this.state.currGrid === \"unweighted\") {\r\n            for (let i = 0; i < GRID_ROWS; i++) {\r\n                for (let j = 0; j < GRID_COLS; j++) {\r\n                    if ((i === unweightedStartNodeY && j === unweightedStartNodeX) || (i === unweightedEndNodeY && j === unweightedEndNodeX)) {\r\n                        continue;\r\n                    }\r\n                    grid[i][j].isWall = Math.random() * 5 > 4;\r\n                    grid[i][j].className = grid[i][j].isWall ? `${algo.grid_square} ${algo.selected}` : `${algo.grid_square} ${algo.unselected}`;\r\n                }\r\n            }\r\n            this.setState({ mainGrid: grid });\r\n        } else {\r\n            for (let i = 0; i < GRID_ROWS; i++) {\r\n                for (let j = 0; j < GRID_COLS; j++) {\r\n                    if ((i === weightedStartNodeY && j === weightedStartNodeX) || (i === weightedEndNodeY && j === weightedEndNodeX)) {\r\n                        grid[i][j].weight = 0;\r\n                        continue;\r\n                    } else {\r\n                        if (Math.random() > 0.5) {\r\n                            grid[i][j].weight = Math.trunc(Math.random() * 4 + 1);\r\n                        } else {\r\n                            grid[i][j].weight = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ mainGrid: grid });\r\n        }\r\n    }\r\n\r\n    clearWeightsAndWalls() {\r\n        let grid = [];\r\n        if (this.state.currGrid === \"unweighted\") {\r\n            for (let i = 0; i < GRID_ROWS; i++) {\r\n                grid.push([]);\r\n                for (let j = 0; j < GRID_COLS; j++) {\r\n                    grid[i].push({\r\n                        id: i + \"-\" + j,\r\n                        isStart: i === unweightedStartNodeY && j === unweightedStartNodeX,\r\n                        isEnd: i === unweightedEndNodeY && j === unweightedEndNodeX,\r\n                        className:\r\n                            i === unweightedStartNodeY && j === unweightedStartNodeX\r\n                                ? `${algo.grid_square} ${algo.start}`\r\n                                : i === unweightedEndNodeY && j === unweightedEndNodeX\r\n                                ? `${algo.grid_square} ${algo.end}`\r\n                                : `${algo.grid_square} ${algo.unselected}`,\r\n                        weight: 0,\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 0; i < GRID_ROWS; i++) {\r\n                grid.push([]);\r\n                for (let j = 0; j < GRID_COLS; j++) {\r\n                    grid[i].push({\r\n                        id: i + \"-\" + j,\r\n                        isStart: i === weightedStartNodeY && j === weightedStartNodeX,\r\n                        isEnd: i === weightedEndNodeY && j === weightedEndNodeX,\r\n                        className:\r\n                            i === weightedStartNodeY && j === weightedStartNodeX\r\n                                ? `${algo.grid_square} ${algo.start}`\r\n                                : i === weightedEndNodeY && j === weightedEndNodeX\r\n                                ? `${algo.grid_square} ${algo.end}`\r\n                                : `${algo.grid_square} ${algo.unselected}`,\r\n                        weight: 0,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        this.setState({ mainGrid: grid });\r\n    }\r\n\r\n    dragAndDropUpdate(id, e) {\r\n        let newGrid = this.state.mainGrid.slice();\r\n        let data = JSON.parse(e.dataTransfer.getData(\"data\"));\r\n\r\n        // sX = startX, sY = startY\r\n        // eX = endX, eY = endY\r\n\r\n        let sY = data[1].substring(0, data[1].indexOf(\"-\"));\r\n        let sX = data[1].substring(data[1].indexOf(\"-\") + 1, data[1].length);\r\n        let eY = id.substring(0, id.indexOf(\"-\"));\r\n        let eX = id.substring(id.indexOf(\"-\") + 1, id.length);\r\n\r\n        if (data[0] === `${algo.start}`) {\r\n            newGrid[sY][sX].isStart = false;\r\n            newGrid[eY][eX].isStart = true;\r\n\r\n            newGrid[sY][sX].className = `${algo.grid_square} ${algo.unselected}`;\r\n            newGrid[eY][eX].className = `${algo.grid_square} ${algo.start}`;\r\n        } else {\r\n            newGrid[sY][sX].isEnd = false;\r\n            newGrid[eY][eX].isEnd = true;\r\n\r\n            newGrid[sY][sX].className = `${algo.grid_square} ${algo.unselected}`;\r\n            newGrid[eY][eX].className = `${algo.grid_square} ${algo.end}`;\r\n        }\r\n\r\n        if (newGrid[eY][eX].isWall) {\r\n            newGrid[eY][eX].isWall = false;\r\n        }\r\n\r\n        if (this.state.currGrid === \"weighted\") {\r\n            newGrid[eY][eX].weight = 0;\r\n        }\r\n\r\n        this.setState({ mainGrid: newGrid });\r\n    }\r\n\r\n    resetGrid() {\r\n        // set visited nodes to blank nodes but not blocked off nodes\r\n        let grid = this.state.mainGrid;\r\n        for (let i = 0; i < GRID_ROWS; i++) {\r\n            for (let j = 0; j < GRID_COLS; j++) {\r\n                // set visited nodes to blank nodes\r\n                let nodeClass = String(grid[i][j].className);\r\n                if (nodeClass.includes(\"visited\") || nodeClass.includes(\"shortestpath\")) {\r\n                    grid[i][j].className = `${algo.grid_square} ${algo.unselected}`;\r\n                }\r\n            }\r\n        }\r\n        this.setState({ mainGrid: grid });\r\n    }\r\n\r\n    /////////////////// Render ///////////////////\r\n    render() {\r\n        const { mainGrid } = this.state;\r\n        return (\r\n            <div className={`${algo.algo_app}`} align=\"center\">\r\n                <Settings changeSpeed={(speed) => this.changeSpeed(speed)} />\r\n                <NavigationBar\r\n                    onClick={() => this.visualizeAlgorithm()}\r\n                    changeAlgorithm={(key) => this.changeAlgorithm(key)}\r\n                    changeGrid={(type) => this.changeGrid(type)}\r\n                    algorithm={this.state.algorithm}\r\n                    generateNewGrid={() => this.generateRandomGrid()}\r\n                    clearWeightsAndWalls={() => this.clearWeightsAndWalls()}\r\n                />\r\n                <Legend graph={this.state.currGrid} />\r\n                <div id={`${algo.grid}`}>\r\n                    {mainGrid.map((row, key) => {\r\n                        return (\r\n                            <div className={`${algo.grid_row}`} key={key}>\r\n                                {row.map((node, key) => {\r\n                                    return (\r\n                                        <Square\r\n                                            {...node}\r\n                                            handleClick={(j, i) => this.handleClick(j, i)}\r\n                                            drag={drag()}\r\n                                            drop={drop(node.id, this.state.currGrid)}\r\n                                            key={key}\r\n                                            dragAndDropUpdate={(e, id) => this.dragAndDropUpdate(e, id)}\r\n                                        />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n                <Timer isRunning={this.state.isRunning} />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst Timer = (props) => {\r\n    const [time, setTime] = useState(0);\r\n\r\n    document.addEventListener(\"click\", (e) => {\r\n        if (e.target.id === \"visualize-btn\") {\r\n            setTime(0);\r\n        }\r\n    });\r\n    useEffect(() => {\r\n        if (props.isRunning == false) {\r\n            return;\r\n        }\r\n        const interval = setInterval(() => {\r\n            setTime(time + 0.1);\r\n        }, 100);\r\n\r\n        return () => clearInterval(interval);\r\n    });\r\n\r\n    return <div style={{ marginTop: \"1em\", fontSize: \"1.5em\" }}>Time elapsed: {time.toFixed(1)} seconds</div>;\r\n};\r\n\r\n// JavaScript functions\r\n\r\n// drag and drop functions\r\nconst drag = () => (e) => {\r\n    let data = [e.target.id, e.target.parentNode.id];\r\n    e.dataTransfer.setData(\"data\", JSON.stringify(data));\r\n};\r\n\r\nconst drop = (id, grid) => (e) => {\r\n    e.preventDefault();\r\n    let data = JSON.parse(e.dataTransfer.getData(\"data\"));\r\n\r\n    // stringEndId represents the node where data is being dropped\r\n\r\n    let stringEndId = String(id);\r\n    let y = parseInt(stringEndId.substring(0, stringEndId.indexOf(\"-\")));\r\n    let x = parseInt(stringEndId.substring(stringEndId.indexOf(\"-\") + 1, stringEndId.length));\r\n    e.target.appendChild(document.getElementById(data[0]));\r\n\r\n    if (grid === \"unweighted\") {\r\n        if (data[0] === `${algo.start}`) {\r\n            unweightedStartNodeX = x;\r\n            unweightedStartNodeY = y;\r\n        } else {\r\n            unweightedEndNodeX = x;\r\n            unweightedEndNodeY = y;\r\n        }\r\n    } else {\r\n        if (data[0] === `${algo.start}`) {\r\n            weightedStartNodeX = x;\r\n            weightedStartNodeY = y;\r\n        } else {\r\n            weightedEndNodeX = x;\r\n            weightedEndNodeY = y;\r\n        }\r\n    }\r\n};\r\n","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Algorithms\\WeightedSearchAlgorithms.js",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Algorithms\\UnweightedSearchAlgorithms.js",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\GridSquare.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\Settings.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\NavBar.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\AlgoVisualizer.js",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\MainPage\\HomeScreen.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\DataStructures.js",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\NavBar.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Toolbar.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Visualizer.jsx",["76"],"import React from \"react\";\r\n\r\nimport Toolbar from \"./Toolbar\";\r\nimport NavBar from \"./NavBar\";\r\nimport Alert from \"./Alert\";\r\n\r\nimport ds from \"../DataStructures.module.css\";\r\n\r\nimport $ from \"jquery\";\r\nimport anime from \"animejs\";\r\n\r\nexport default class DSVisualizer extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      behavior: \"list\",\r\n      functions: [\"add\", \"remove\"],\r\n      structure: [1, 2, 3],\r\n    };\r\n\r\n    this.add = this.add.bind(this);\r\n    this.remove = this.remove.bind(this);\r\n    this.enqueue = this.enqueue.bind(this);\r\n    this.dequeue = this.dequeue.bind(this);\r\n    this.push = this.push.bind(this);\r\n    this.pop = this.pop.bind(this);\r\n  }\r\n\r\n  handleChange(key) {\r\n    switch (key) {\r\n      case \"list\":\r\n        this.setState({ functions: [\"add\", \"remove\"] });\r\n        break;\r\n      case \"set\":\r\n        this.setState({ functions: [\"add\", \"remove\"] });\r\n\r\n        let struct = this.state.structure.slice();\r\n        struct = [...new Set(struct)];\r\n        this.setState({ structure: struct });\r\n        break;\r\n      case \"queue\":\r\n        this.setState({ functions: [\"enqueue\", \"dequeue\"] });\r\n        break;\r\n      case \"deque\":\r\n        this.setState({\r\n          functions: [\"enqueueF\", \"dequeueF\", \"enqueueB\", \"dequeueB\"],\r\n        });\r\n        break;\r\n      case \"stack\":\r\n        this.setState({ functions: [\"push\", \"pop\"] });\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    this.setState({ behavior: key });\r\n  }\r\n\r\n  // behavior functions\r\n\r\n  add(index, value) {\r\n    if (value === \"\") {\r\n      $(\"#alert_text\").text(\"Please select enter a value!\");\r\n      $(`.${ds.alertBG}`).fadeIn();\r\n      return;\r\n    }\r\n\r\n    if (this.state.behavior === \"set\" && this.state.structure.includes(value)) {\r\n      $(\"#alert_text\").text(\"The value is already in the set!\");\r\n      $(`.${ds.alertBG}`).fadeIn();\r\n      return;\r\n    }\r\n\r\n    let struct = this.state.structure.slice();\r\n    if (index === \"\") {\r\n      this.addAnim(struct.length - 1, value);\r\n    } else if (parseInt(index) > struct.length) {\r\n      $(\"#alert_text\").text(`Cannot add at index ${index}`);\r\n      $(`.${ds.alertBG}`).fadeIn();\r\n      return;\r\n    } else {\r\n      this.addAnim(index, value);\r\n      return;\r\n    }\r\n  }\r\n\r\n  remove(index) {\r\n    let struct = this.state.structure.slice();\r\n    if (struct.length === 0) {\r\n      $(\"#alert_text\").text(\r\n        `The ${this.state.behavior} is empty! There's nothing to remove!`\r\n      );\r\n      $(`.${ds.alertBG}`).fadeIn();\r\n      return;\r\n    } else if (struct.length <= index) {\r\n      $(\"#alert_text\").text(`No element exists at index ${index}!`);\r\n      $(`.${ds.alertBG}`).fadeIn();\r\n      return;\r\n    }\r\n\r\n    if (index === \"\") {\r\n      this.remAnim(struct.length - 1);\r\n    } else if (parseInt(index) >= struct.length) {\r\n      return;\r\n    } else {\r\n      this.remAnim(index);\r\n    }\r\n  }\r\n\r\n  enqueue(value) {\r\n    if (value === \"\") {\r\n      $(\"#alert_text\").text(\"Please select enter a value!\");\r\n      $(`.${ds.alertBG}`).fadeIn();\r\n      return;\r\n    }\r\n    this.addAnim(Math.min(this.state.structure.length - 1, 0), value);\r\n  }\r\n\r\n  dequeue() {\r\n    let struct = this.state.structure.slice();\r\n    if (struct.length === 0) {\r\n      $(\"#alert_text\").text(\"Queue is empty! There's nothing to dequeue!\");\r\n      $(`.${ds.alertBG}`).fadeIn();\r\n    }\r\n    this.remAnim(struct.length - 1);\r\n  }\r\n\r\n  push(value) {\r\n    if (value === \"\") {\r\n      $(\"#alert_text\").text(\"Please select enter a value!\");\r\n      $(`.${ds.alertBG}`).fadeIn();\r\n      return;\r\n    }\r\n    this.addAnim(this.state.structure.length - 1, value);\r\n  }\r\n\r\n  pop() {\r\n    let struct = this.state.structure.slice();\r\n    if (struct.length === 0) {\r\n      $(\"#alert_text\").text(\"Stack is empty! There's nothing to pop!\");\r\n      $(`.${ds.alertBG}`).fadeIn();\r\n    }\r\n    this.remAnim(struct.length - 1);\r\n  }\r\n\r\n  // animation functions\r\n\r\n  addAnim(index, value) {\r\n    let struct = this.state.structure;\r\n    if (index === struct.length - 1) {\r\n      struct.push(value);\r\n      this.setState({ structure: struct }, () => {\r\n        $(`#item_${index + 1}`)\r\n          .css(\"display\", \"none\")\r\n          .fadeIn(150);\r\n      });\r\n    } else {\r\n      struct.splice(index, 0, value);\r\n      let comps = [];\r\n      for (let i = parseInt(index); i < struct.length; i++) {\r\n        comps.push(`#item_${i}`);\r\n      }\r\n\r\n      anime({\r\n        targets: comps,\r\n        translateX: \"5em\",\r\n        duration: 250,\r\n        complete: () => {\r\n          this.setState({ structure: struct }, () => {\r\n            anime({ targets: comps, translateX: 0, duration: 0 });\r\n          });\r\n        },\r\n      });\r\n    }\r\n  }\r\n\r\n  remAnim(index) {\r\n    let struct = this.state.structure;\r\n    if (index === struct.length - 1) {\r\n      $(`#item_${index}`).fadeOut(150, () => {\r\n        struct.pop();\r\n        this.setState({ structure: struct });\r\n      });\r\n    } else {\r\n      let half1 = struct.slice(0, index);\r\n      let half2 = struct.slice(parseInt(index) + 1);\r\n      struct = half1.concat(half2);\r\n\r\n      let comps = [];\r\n      for (let i = parseInt(index) + 1; i <= struct.length; i++) {\r\n        comps.push(`#item_${i}`);\r\n      }\r\n\r\n      // get rid of animation and just use fade?\r\n      var timeline = anime.timeline({ autoplay: \"false\" });\r\n\r\n      timeline.add({ targets: comps, translateX: \"-5em\", duration: 250 }).add({\r\n        targets: comps,\r\n        translateX: 0,\r\n        duration: 0,\r\n        complete: () => {\r\n          this.setState({ structure: struct });\r\n        },\r\n      });\r\n\r\n      $(`#item_${index}`)\r\n        .fadeOut(150)\r\n        .fadeIn(150);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <NavBar onchange={(key) => this.handleChange(key)} />\r\n        <Toolbar\r\n          functions={this.state.functions}\r\n          btns={this.state.functions}\r\n          add={this.add}\r\n          remove={this.remove}\r\n          enqueue={this.enqueue}\r\n          dequeue={this.dequeue}\r\n          push={this.push}\r\n          pop={this.pop}\r\n        />\r\n        <Alert />\r\n\r\n        <div style={{ marginLeft: \"1.5em\" }}>\r\n          {this.state.structure.map((item, key) => {\r\n            if (key === 0 || key === this.state.structure.length - 1) {\r\n              if (this.state.structure.length - 1 == 0) {\r\n                return (\r\n                  <div className={ds.item} id={`item_${key}`} key={key}>\r\n                  <div>{item}</div>\r\n                  <div style={{ fontSize: \"0.65em\" }}>\r\n                    Head {' & '}\r\n                    Tail\r\n                  </div>\r\n                </div>\r\n              );\r\n              } else {\r\n                return (\r\n                  <div className={ds.item} id={`item_${key}`} key={key}>\r\n                  <div>{item}</div>\r\n                  <div style={{ fontSize: \"0.7em\" }}>\r\n                    {key === 0 ? \"Head\" : \"Tail\"}\r\n                  </div>\r\n                </div>\r\n              );\r\n            }\r\n            } else {\r\n              return (\r\n                <div className={ds.item} id={`item_${key}`} key={key}>\r\n                  {item}\r\n                </div>\r\n              );\r\n            }\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\DS's\\Components\\Alert.jsx",[],"C:\\Users\\rosea\\Documents\\Github\\DS-and-Algorithm-Visualizer\\src\\Algo\\Components\\Legend.jsx",["77"],{"ruleId":"78","replacedBy":"79"},{"ruleId":"80","replacedBy":"81"},{"ruleId":"82","severity":1,"message":"83","line":469,"column":29,"nodeType":"84","messageId":"85","endLine":469,"endColumn":31},{"ruleId":"82","severity":1,"message":"83","line":230,"column":51,"nodeType":"84","messageId":"85","endLine":230,"endColumn":53},{"ruleId":"86","severity":1,"message":"87","line":8,"column":5,"nodeType":"88","messageId":"89","endLine":10,"endColumn":6},"no-native-reassign",["90"],"no-negated-in-lhs",["91"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-global-assign","no-unsafe-negation"]